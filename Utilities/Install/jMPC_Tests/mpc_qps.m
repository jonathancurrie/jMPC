function [QP,MPC] = mpc_qps(Np,Nc,n_in,n_out,states,no,scale)
%MPC_QPS Create QP problems based on an MPC formulation
%   
%   [QP,MPC1] = mpc_qps(Np,Nc,n_in,n_out,states,no,scale) returns a structure QP
%   of no MPC QP problems. Np & Nc specify the horizons, while n_in, n_out
%   & states specify the number of inputs, outputs and states, respectively. 
%   Each QP uses a discrete random model generated by 'drmodel'.
%
%   See also drmodel

if(nargin < 7), scale = 1; end
if(nargin < 6 || isempty(no)), no = 10; end

%Static Constraints
con.u = [-1*ones(n_in,1)  1*ones(n_in,1)  0.1*ones(n_in,1)];   %in1 umin umax delumax
con.y = [0*ones(n_out,1) 1.01*ones(n_out,1)];      %out1 ymin ymax
%Static Weighting
uwt = ones(n_in,1);
ywt = ones(n_out,1);
%Static Variables
yp = zeros(n_out,1);
setp = 1*ones(1,n_out);
warningstate1 = warning('off', 'jMPCToolbox:SETP'); %turn off setpoint shorter warning

%Preallocate Return Variable
QP.H = zeros(Nc*n_in,Nc*n_in,no);
QP.f = zeros(Nc*n_in,no);
QP.A = zeros(4*Nc*n_in+2*Np*n_out,Nc*n_in,no);
QP.b = zeros(size(QP.A,1),no);
MPC = cell(no,1);
opts = jMPCset('ScaleSystem',scale);

for k = 1:no
    %Create Random Model
    [A,B,C,D] = drmodel(states,n_out,n_in);
    Model = jSS(A,B,C,zeros(n_in,n_out),0.1); Model.x0 = zeros(states,1); 
    %-- Build MPC --%
    MPC1 = jMPC(Model,Np,Nc,uwt,ywt,con,[],opts);

    %Allocate initial values
    sModel = MPC1.Model;
    u = MPC1.initial.u;
    del_xm = sModel.x0;

    %State Estimator Update
    del_xm = MPC1.state_est.IKC*del_xm + MPC1.state_est.Kest*yp;
    %Update Dynamic RHS of QP Problem
    [b,f] = MPC1.update_rhs(del_xm,u,setp,0,k); 
    
    %Save dynamic QP variables
    QP.H(:,:,k) = MPC1.QP.H;
    QP.f(:,k) = f;
    QP.A(:,:,k) = MPC1.constraints.A;
    QP.b(:,k) = b;
    MPC{k} = MPC1;
end

%Restore warning
warning(warningstate1)

end
